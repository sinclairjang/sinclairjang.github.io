---
title: Formula R&D &num;0. 아키텍쳐
date: 2022-11-04 20:22:00 +0900
categories: [Project, Devlog]
tags: [game engine]
---


> 본 프로젝트의 목적은 다음과 같습니다.
{: .prompt-tip }
1. 다중 플랫폼 구현
2. 다중 그래픽스 API를 활용한 렌더 파이프라인 구현
3. 전반적인 게임 제작 프로세스 구현
4. 다양한 최신 기술에 대한 샌드박스 플랫폼 구현




## 멀티 플랫폼 게임 엔진 아키텍쳐

---


> 게임엔진은 크고 복잡한 소프트웨어 입니다. 그런만큼 그것을 구성하는 여러 컴포넌트를 기능 및 역할별로 분해하는 것으로 개발, 유지, 보수시 작업효율성을 크게 높일 수 있습니다. 저는 복잡성을 관리하기 위한 소프트웨어 아키텍쳐의 중요성을 인지하고 있고 그것의 주요 원리로 인정되고 있는 SOLID을 준수하고자 노력하려고 합니다.
{: .prompt-tip }


## 프론트엔드

---

> 본 툴의 사용성 제고를 위해 유저가 각 플랫폼 구현부에 최대한 노출되지 않도록 API를 디자인 합니다.
{: .prompt-tip }

### UI 프레임워크

---

> 게임 오브젝트를 생성, 수정, 제거할 수 있는 위젯을 정의합니다.
{: .prompt-tip }


게임 컨텐츠 제작의 핵심은 게임 오브젝트(메쉬, 카메라, 빛 등)의 속성(위치, 행동 등)을 게임 엔진의 여러가지 하위 시스템(3D 모델링, 물리, 애니메이션, 카메라 등)을 활용하여 정의하는 것입니다. 게임 엔진은 유저가 위 과정을 보다 손쉽고 효율적으로 할 수 있도록 그래픽 인터페이스(라디오 버튼, 슬라이더 등 각종 위젯)를 제공합니다. 

본 프로젝트는 이러한 UI 프레임워크로 ImGui 라이브러리를 이용합니다.

ImGui(Immediate Mode Graphical User Interface)은 기존의 UI 툴 개발 방식으로 많이 쓰였던 Retained Mode와는 상반되는 패러다임입니다. 각각의 용어를 우리말인 **즉각 방식**, **간직 방식**으로 표현하겠습니다. 

간직 방식은 말 그대로 UI 오브젝트의 크기, 위치, 이벤트 정보와 렌더링에 필요한 메쉬 정보 등과 같은 각종 스테이트를 메모리에 간직함으로써 매 프레임 그것을 정의할 필요가 없습니다. 반면에 즉각 방식은 그러한 스테이트를 매 프레임마다 정의하며 그 데이터를 메모리에 보유하지 않습니다. 

그래픽을 프로세싱할 때 필요한 메모리 수용량과 스루풋이 많이 향상되면서 매 프레임마다 UI 상태 데이터를 전송하는 것에 따른 부하가 완화되었습니다. 그렇다고 해도 즉각 방식에 간직 방식보다 더 많은 프로세싱이 수반되는 것은 분명하기 때문에 그런 엑스트라 프로세싱이 더 의미가 있는지 살펴보아야 합니다.

매 프레임 UI 상태를 정의한다는 것의 의미를 아래 버튼을 정의하는 코드를 통해 이해할 수 있습니다.

```cpp
const bool Gui::button(const int aX, const int aY,
                       const int aWidth, const int aHeight,
                       const char* aText)
{
    // 버튼 그리기
    drawRect(aX, aY, aWidth, aHeight); 
    drawText(aX, aY, aText);           

    // 바운딩박스 안에서 왼쪽 버튼 클릭시 버튼 트리거
    return mouse::leftButtonPressed() &&
           mouse::cursorX() >= aX &&
           mouse::cursorY() >= aY &&
           mouse::cursorX() < (aX + aWidth) &&
           mouse::cursorY() < (aY + aHeight);
}

//출처: http://www.johno.se/book/imgui.html
```

먼저 우리의 눈에 들어오는 것은 버튼을 정의하는 클래스(오브젝트)와 멤버 변수(상태 정보)가 없다는 점입니다. 대신에 함수와 그의 파라미터로 대체되었습니다. 이를 통해 오브젝트 간 UI 상태 정보의 복사 이동에 따른 데이터 중복, 동기화, 그리고 그에 연계된 동작을 정의하는 콜백함수가 없어 코드가 훨씬 간결해지는 것을 볼 수 있습니다. 

이는 위 버튼의 예에서도 확인 할 수 있습니다. 버튼과 관련된 상태 데이터는 해당 함수 스코프안에서만 소비되고 있고 버튼과 연계된 동작은 아래 코드에서 보듯이 싱글 유저 인터렉션을 단위로 명시적으로 정의되기 때문에 간결하고 명확합니다. 

```cpp
if(button(aX, aY, aWidth, aHeight, aText)) 
{
	doSomething(...); // 버튼 클릭 시 실행
}
```

이는 근래 객체지향 프로그래밍 패러다임의 한계가 부각되면서 다른 방식의 프로그래밍, 특히 함수형 프로그램이 대두되고 있는 것과도 맞물립니다. 특히 함수형 프로그래밍에서의 순수 함수에 해당한다고 볼 수 있습니다. 사이드 이펙트의 존재 유무에 따라 액션, 순수 함수, 단순 데이터로 분해합니다.

> 함수형 프로그래밍에서는 사이드 이펙트의 존재 유무에 따라 액션, 순수 함수, 단순 데이터로 나누어 생각하도록 프로그래밍 언어가 디자인 됩니다. 이는 컴퓨터 프로세서와 메모리 성능간의 격차로 병목이 된 메모리 때문에 수요가 높아진 평행 연산, 분산시스템 등 멀티쓰레딩에 수반되는 복잡성을 완화하는데 결정적 역할을 합니다.
{: .prompt-tip }

![](commons/perf_gap.png)
*컴퓨터 하드웨어 제작 기술의 발전에 따라 컴퓨터 프로세서와 메모리 성능간의 격차는 계속 벌어져왔다. <br> 출처: [Game Programming Patterns by Robert Nystrom](https://gameprogrammingpatterns.com/data-locality.html) <br>* 

#### 구현

---

[main.h](https://github.com/sinclairjang/ByteChemy/blob/master/Formula/src/backends/frameworks/dx12_on_win32/main.h)

```cpp
int main(int, char**)
{
  ...
  // 새 ImGui 프레임 시작
  ImGui::NewFrame();
	
  //TODO: 이곳에 각종 위젯을 빌드합니다.
  ...
		
  // 렌더러에 렌더에 필요한 배치 데이터 전송
  ImGui::Render();
  ...
}
```

### 클라이언트

---

> 클라이언트 어플리케이션의 코어 로직을 정의합니다.
{: .prompt-tip }


게임 컨텐츠 제작의 핵심은 게임 오브젝트(메쉬, 카메라, 빛 등)의 속성(위치, 행동, 머테리얼 등)을 게임 엔진의 여러가지 하위 시스템(3D 모델링, 물리, 애니메이션, 카메라, 스크립트 등)을 활용하여 정의하는 것입니다. 게임 엔진은 유저가 위 과정을 보다 손쉽고 효율적으로 할 수 있도록 그래픽 인터페이스(라디오 버튼, 슬라이더 등 각종 위젯)를 제공합니다. 

앞의 버튼의 예를 들어 좀 더 구체적으로 어떻게 위젯에 반응하는 동작을 정의할 수 있는지 살펴보겠습니다.

```cpp
GameObject Player;

//NOTE: 해당 게임 오브젝트가 마우스 픽 되었을 때에만 연계된 위젯이 렌더링되고 인터랙션이 생성된다.
if(Player.MousePicked(...))
{
  ...
  if(button(aX, aY, aWidth, aHeight, "+X 이동")) 
  {
	Player->Physics.AddForce(...);
	Player->Anim.Animate(...);
	...
  }
  ...
}
```

동작에 대한 정의는 했으니 그 동작의 주체에 해당하는 게임 오브젝트에 대한 정의를 해보겠습니다. 무엇인가를 정의한 다는 것은 그것을 다른것과 구분짓는 속성을 정의하는 것이고 이를 통해 구분지어지면 그것의 아이덴티티가 생성됩니다.  게임 오브젝트의 경우에는 주로 렌더링과 연계된 속성(메쉬, 머테리얼, 위치 등)으로서 구분됩니다.  

그런데 그렇게 생성된 아이덴티티를 구현할 때 위의 Player의 예에서 보여지는 것처럼 자신 안에 물리, 애니메이션 

|  | Mesh | Material | Position |
| --- | --- | --- | --- |
| Player |  |  |  |
| Monster |  |  |  |

|  | Player | Monster |
| --- | --- | --- |
| Mesh |  |  |
| Material |  |  |
| Position |  |  |

## 백엔드

### 이벤트 핸들링: 유저 이벤트 (키보드, 마우스, 게임패드 등) 처리

### 렌더링: 게임 및 UI 오브젝트 렌더링











